include(`tables.ccn')
include(`views.ccn')

switch SChassis[Chassis]

port PVSwitchPort[VSwitchPort](source vSwitchIngress, sink)

procedure vSwitchIngress(port: VSwitchPort): sink = {
    var lport : LogicalSwitchPort;
    if (pkt.vlan.vid == 0) {
        the (p in LogicalSwitchPort | p.id == port.id and p.enabled) {
            lport = p
        } default { drop }
    } else {
        // trunk port? find VIF interface; strip vlan tag
        the (p in LogicalSwitchPort | p.ptype.parent == p.id and p.ptype.tag == pkt.vlan.vid and p.enabled) {
            lport = p;
            pkt.vlan.vid = 0
        } default { drop }
    };
   
    lportIngress(lport, pkt)
}

procedure lportIngress(lport: LogicalSwitchPort, p: Packet): sink = {
    if (not portSecurityAllowed(lport, pkt)) drop;
    // Run through connection tracker if needed
    connTrack(lport);

/*
    (allowed, commit) = acl();
    if (not aclAllowed(lport)) drop;
    // QoS marking??
    lb(commit);
    arp();
    dhcp();
    dns();
    if (multicast/broadcast) {
    } else {
    }
*/
    drop
}

function portSecurityAllowed(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress table 0 contains these logical flows:
        · Priority 100 flows to drop packets with VLAN tags or mul‐
          ticast Ethernet source addresses.

        · Priority  50  flows  that implement ingress port security
          for each enabled logical port. For logical ports on which
          port  security is enabled, these match the inport and the
          valid eth.src address(es) and advance only those  packets
          to  the  next flow table. For logical ports on which port
          security is not enabled, these advance all  packets  that
          match the inport.

        There  are no flows for disabled logical ports because the default-drop
        behavior of logical flow tables causes packets that ingress  from  them
        to be dropped. 
    */
    if (ethMulticastAddr(p.src)) {
        false 
    } else { 
        the (psec in PortSecurityType | psec.lport == lport.id) {
            if (psec.stype == PortSecNone) { true }
            else {
                the (psecmac in PortSecurityMAC | psecmac.lport == lport.id and psecmac.mac == p.src) {
                    match ((p.payload, psec.stype)) {
                        (EthARP{_}, _)   -> portSecARP(lport, p),
                        (EthOther{_}, _) -> true,
                        (_, PortSecIP)   -> portSecIP(lport, p),
                        _                -> true
                    }
                } default { false }
            }
        }
    }
}

function portSecIP(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress Table 1: Ingress Port Security - IP
       Ingress table 1 contains these logical flows:
          · For each element in the port security set having one or more IPv4 or IPv6 addresses (or both),
             · Priority 90 flow to allow IPv4 traffic if it has IPv4 addresses which match the inport, valid eth.src and valid ip4.src address(es).
             · Priority 90 flow to allow IPv4 DHCP discovery traffic if it has a valid eth.src. This is necessary since  DHCP  discovery  messages are sent from the unspecified IPv4 address (0.0.0.0) since the IPv4 address has not yet been assigned.
             · Priority 90 flow to allow IPv6 traffic if it has IPv6 addresses which match the inport, valid eth.src and valid ip6.src address(es).
             · Priority  90  flow  to  allow  IPv6  DAD (Duplicate Address Detection) traffic if it has a valid eth.src. This is is necessary since DAD include requires joining an multicast group and sending neighbor solicitations for the newly assigned address. Since no address  is  yet assigned, these are sent from the unspecified IPv6 address (::).
             · Priority 80 flow to drop IP (both IPv4 and IPv6) traffic which match the inport and valid eth.src.
          · One priority-0 fallback flow that matches all packets and advances to the next table.
    */
    if (isPktDHCPDiscovery(p) or isPktDAD(p)) {
        true
    } else {
        the (psecip in LogicalSwitchPortIP | psecip.lport == lport.id and psecip.mac == p.src and ipSrcMatch(p.payload, psecip.ip)) {
            portSecNDP(lport, p)
        } default { false }
    }
}

function ipSrcMatch(p: eth_payload_t, subnet: ip_subnet_t): bool = {
    match ((p, subnet)) {
        (EthIP4{ip4}, IPSubnet4{subnet4}) -> ip4Match(ip4.src, subnet4),
        (EthIP6{ip6}, IPSubnet6{subnet6}) -> ip6Match(ip6.src, subnet6),
        _                                 -> false
    }
}

function isPktDHCPDiscovery(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,EthIP4{IP4Pkt{_,_,_,_,_,_,_,_,sip,dip,IPUDP{UDPPkt{sport,dport,_}}}}} -> 
            sip == 0 and dip == 32'hffffffff and sport == 68 and dport == 67,
        _                                                                                          -> false
    }
}

function isPktDAD(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,sip,_,IPICMP6{ICMP6Pkt{ptype,_,_}}}}} -> ptype == 135 and sip == 0,
        _                                                                                  -> false
    }
}

/* Ingress Table 2: Ingress Port Security - Neighbor discovery
   Ingress table 2 contains these logical flows:
      · For each element in the port security set,
         · Priority  90  flow  to  allow  ARP  traffic  which  match  the inport and valid eth.src and arp.sha. If the element has one or more IPv4 addresses, then it also matches the valid arp.spa.
         · Priority 90 flow to allow IPv6 Neighbor Solicitation and Advertisement traffic which match the inport, valid eth.src and  nd.sll/nd.tll.  If the element has one or more IPv6 addresses, then it also matches the valid nd.target address(es) for Neighbor Advertisement traffic.
         · Priority 80 flow to drop ARP and IPv6 Neighbor Solicitation and Advertisement traffic which match the inport and valid eth.src.
      · One priority-0 fallback flow that matches all packets and advances to the next table.
*/
function portSecARP(lport: LogicalSwitchPort, p: Packet): bool = {
    the (psecarp in PortSecurityIP4Match | psecarp.lport == lport.id and 
                                           psecarp.mac == p.src and 
                                           psecarp.mac == p.payload.arp.sha and 
                                           ip4Match(p.payload.arp.spa, psecarp.subnet)) {
        true
    } default { false }
}

function portSecNDP(lport: LogicalSwitchPort, p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NS{ICMP6NSPkt{_, sll}}}}}}} -> 
            the (psec in PortSecurityMAC | psec.lport == lport.id and psec.mac == p.src and psec.mac == sll) {
                true
            } default { false },
        EthPacket {_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NA{ICMP6NAPkt{target, tll}}}}}}} -> 
            the (psec in PortSecurityIP6Match | psec.lport == lport.id and psec.mac == p.src and psec.mac == tll and ip6Match(target, psec.subnet)) {
                true
            } default { false },
        _ -> true
    }
}

procedure connTrack(lport : LogicalSwitchPort): () = {
    var needCT = false;
    the (lp in LPortStatefulACL | lp.lport == lport.id) {
        needCT = true
    } default { () };

    the (lbvip in LPortLBVIP | lbvip.lport == lport.id and lbvip.vip == pkt.payload.ip4.dst) {
        needCT = true
    } default { () }

    // TODO: call ct
}

procedure lportEgress(port: LogicalSwitchPort): sink = drop 
