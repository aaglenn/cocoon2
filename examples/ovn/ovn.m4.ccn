include(`tables.ccn')
include(`views.ccn')
undefine(`eval')

switch SChassis[Chassis]

port PVSwitchPort[VSwitchPort](source vSwitchIngress, sink)
port PTunnelPort[TunnelPort](source tunIngress, sink)

procedure vSwitchIngress(port: VSwitchPort): sink = {
    var lport : LogicalSwitchPort;
    var lpid = the (lb in LPortBinding | lb.vport == port.id) { lb.lport};
    if (pkt.vlan.vid == 0) {
        the (p in LogicalSwitchPort | p.id == lpid and p.enabled) {
            lport = p
        } default { drop }
    } else {
        // trunk port? find VIF interface; strip vlan tag
        the (p in LogicalSwitchPort | match (p.ptype) { 
                                          LPortVIF{parent,_,tag} -> parent == lpid and tag == pkt.vlan.vid and p.enabled,
                                          _ -> false
                                      } ) {
            lport = p;
            pkt.vlan.vid = 0
        } default { drop }
    };
   
    lportIngress(lport, port.switch)
}


// XXX: TODO: QoS marking
procedure lportIngress(lport: LogicalSwitchPort, chassis : chassis_id_t): sink = {
    if (not ingressPortSecurity(lport, pkt)) drop;

    /* Run through connection tracker if needed */
    ingressConnTrack(lport);

    /* acl */
    (var allowed, var commit) = acl(lport, ACLFrom);
    if (not allowed) drop;

    /* load balancing */
    ingressLB(lport, commit);

    /* ARP/ND */
    var arpresp = arp(lport);
    if (arpresp) { bounce(lport, chassis) };

    /* DHCP/DNS */
    match (pkt.payload) {
        EthIP4{IP4Pkt{_,_,_,_,_,_,_,_,_, IPUDP{UDPPkt{src, dst, _, _}}}} -> if (src == 68 and dst == 67)   { dhcp4(lport.id, chassis) } else { () },
        EthIP6{IP6Pkt{_,_,_,_,_,_,_, IPUDP{UDPPkt{src, dst, _, _}}}}       -> if (src == 546 and dst == 547) { dhcp6(lport.id, chassis) } else { () },
        _   -> ()
    };

    if pktIsDNSReq(pkt) {
        dns(lport.id)
    };

    /* destination lookup */
    dstLookup(lport, chassis)
}

function ingressPortSecurity(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress table 0 contains these logical flows:
        · Priority 100 flows to drop packets with VLAN tags or mul‐
          ticast Ethernet source addresses.

        · Priority  50  flows  that implement ingress port security
          for each enabled logical port. For logical ports on which
          port  security is enabled, these match the inport and the
          valid eth.src address(es) and advance only those  packets
          to  the  next flow table. For logical ports on which port
          security is not enabled, these advance all  packets  that
          match the inport.

        There  are no flows for disabled logical ports because the default-drop
        behavior of logical flow tables causes packets that ingress  from  them
        to be dropped. 
    */
    if (ethMulticastAddr(p.src)) {
        false 
    } else { 
        the (psec in PortSecurityType | psec.lport == lport.id) {
            if (psec.stype == PortSecNone) { true }
            else {
                the (psecmac in PortSecurityMAC | psecmac.lport == lport.id and psecmac.mac == p.src) {
                    match ((p.payload, psec.stype)) {
                        (EthARP{_}, _)   -> portSecARP(lport, p),
                        (EthOther{_}, _) -> true,
                        (_, PortSecIP)   -> ingressPortSecIP(lport, p),
                        _                -> true
                    }
                } default { false }
            }
        }
    }
}

function ingressPortSecIP(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress Table 1: Ingress Port Security - IP
       Ingress table 1 contains these logical flows:
          · For each element in the port security set having one or more IPv4 or IPv6 addresses (or both),
             · Priority 90 flow to allow IPv4 traffic if it has IPv4 addresses which match the inport, valid eth.src and valid ip4.src address(es).
             · Priority 90 flow to allow IPv4 DHCP discovery traffic if it has a valid eth.src. This is necessary since  DHCP  discovery  messages are sent from the unspecified IPv4 address (0.0.0.0) since the IPv4 address has not yet been assigned.
             · Priority 90 flow to allow IPv6 traffic if it has IPv6 addresses which match the inport, valid eth.src and valid ip6.src address(es).
             · Priority  90  flow  to  allow  IPv6  DAD (Duplicate Address Detection) traffic if it has a valid eth.src. This is is necessary since DAD include requires joining an multicast group and sending neighbor solicitations for the newly assigned address. Since no address  is  yet assigned, these are sent from the unspecified IPv6 address (::).
             · Priority 80 flow to drop IP (both IPv4 and IPv6) traffic which match the inport and valid eth.src.
          · One priority-0 fallback flow that matches all packets and advances to the next table.
    */
    if (isPktDHCPDiscovery(p) or isPktDAD(p)) {
        true
    } else {
        the (psecip in PortSecurityIP | psecip.lport == lport.id and psecip.mac == p.src and ipSrcMatch(p.payload, psecip.subnet)) {
            ingressPortSecNDP(lport, p)
        } default { false }
    }
}

function ipSrcMatch(p: eth_payload_t, subnet: ip_subnet_t): bool = {
    match ((p, subnet)) {
        (EthIP4{ip4}, IPSubnet4{subnet4}) -> ip4Match(ip4.src, subnet4),
        (EthIP6{ip6}, IPSubnet6{subnet6}) -> ip6Match(ip6.src, subnet6),
        _                                 -> false
    }
}

function isPktDHCPDiscovery(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,_,EthIP4{IP4Pkt{_,_,_,_,_,_,_,sip,dip,IPUDP{UDPPkt{sport,dport,_,_}}}}} -> 
            sip == 0 and dip == 32'hffffffff and sport == 68 and dport == 67,
        _                                                                                            -> false
    }
}

function isPktDAD(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,sip,_,IPICMP6{ICMP6Pkt{ptype,_,_}}}}} -> ptype == 135 and sip == 0,
        _                                                                                    -> false
    }
}

/* Ingress Table 2: Ingress Port Security - Neighbor discovery
   Ingress table 2 contains these logical flows:
      · For each element in the port security set,
         · Priority  90  flow  to  allow  ARP  traffic  which  match  the inport and valid eth.src and arp.sha. If the element has one or more IPv4 addresses, then it also matches the valid arp.spa.
         · Priority 90 flow to allow IPv6 Neighbor Solicitation and Advertisement traffic which match the inport, valid eth.src and  nd.sll/nd.tll.  If the element has one or more IPv6 addresses, then it also matches the valid nd.target address(es) for Neighbor Advertisement traffic.
         · Priority 80 flow to drop ARP and IPv6 Neighbor Solicitation and Advertisement traffic which match the inport and valid eth.src.
      · One priority-0 fallback flow that matches all packets and advances to the next table.
*/
function portSecARP(lport: LogicalSwitchPort, p: Packet): bool = {
    the (psecarp in PortSecurityIP4Match | psecarp.lport == lport.id and 
                                           psecarp.mac == p.src and 
                                           match (p.payload) {
                                               EthARP{ARPPkt{_,spa,_,sha,_}} -> (psecarp.mac == sha) and ip4Match(spa, psecarp.subnet),
                                               _                             -> false
                                           } ) {
        true
    } default { false }
}

function ingressPortSecNDP(lport: LogicalSwitchPort, p: Packet): bool = {
    match (p.payload) {
        EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NS{ICMP6NSPkt{_, sll}}}}}} -> 
            the (psec in PortSecurityMAC | psec.lport == lport.id and psec.mac == p.src and psec.mac == sll) {
                true
            } default { false },
        EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NA{ICMP6NAPkt{target, tll}}}}}} -> 
            the (psec in PortSecurityIP6Match | psec.lport == lport.id and psec.mac == p.src and psec.mac == tll and ip6Match(target, psec.subnet)) {
                true
            } default { false },
        _ -> true
    }
}
/*
 Ingress Table 3: from-lport Pre-ACLs
   This table prepares flows for possible stateful ACL processing in ingress table ACLs.  It contains a priority-0 flow that  simply moves traffic to the next table.  If stateful ACLs are used in the logical datapath, a priority-100 flow is added that sets a hint (with reg0[0] = 1; next;) for table Pre-stateful to send IP packets to the connection tracker before eventually  advancing to ingress table ACLs.

 Ingress Table 4: Pre-LB
   This table prepares flows for possible stateful load balancing processing in ingress table LB and Stateful.  It contains a priority-0 flow that simply moves traffic to the next table.  If load balancing rules with virtual IP addresses  (and  ports)  are configured  in  OVN_Northbound database for a logical switch datapath, a priority-100 flow is added for each configured virtual IP address VIP with a match ip && ip4.dst == VIP that sets an action reg0[0] = 1; next; to act as a hint for table Pre-stateful to send IP packets to  the  connection  tracker for packet de-fragmentation before eventually advancing to ingress table LB.

 Ingress Table 5: Pre-stateful
   This table prepares flows for all possible stateful processing in next tables.  It contains a priority-0 flow that simply moves traffic to the next table.  A priority-100 flow sends the packets to connection tracker based on a hint provided by the  previous tables (with a match for reg0[0] == 1) by using the ct_next; action.
*/

procedure ingressConnTrack(lport : LogicalSwitchPort): () = {
    var needCT = false;
    the (lp in LPortStatefulACL | lp.lport == lport.id) {
        needCT = true
    } default { () };

    the (lbvip in LPortLBVIP | lbvip.lport == lport.id and 
                               match (pkt.payload) {
                                   EthIP4{ip4} -> lbvip.vip.addr == ip4.dst,
                                   _           -> false
                               } ) {
        needCT = true
    } default { () };

    // sends the packet to connection tracker
    if needCT {
        ct(lport.ct_zone)
    }
}

/*
     Ingress table 6: from-lport ACLs
       Logical  flows  in this table closely reproduce those in the ACL table in the OVN_Northbound database for the from-lport direction. The priority values from the ACL table have a limited range and have 1000 added to them to leave  room  for  OVN  default flows at both higher and lower priorities.
    · allow  ACLs translate into logical flows with the next; action.  If there are any stateful ACLs on this datapath, then allow ACLs translate to ct_commit; next; (which acts as a hint for the next tables to commit the  connection to conntrack),
    · allow-related  ACLs  translate into logical flows with the ct_commit(ct_label=0/1); next; actions for new connections and reg0[1] = 1; next; for existing connections.
    · Other ACLs translate to drop; for new or untracked connections and  ct_commit(ct_label=1/1);  for  known  connections.   Setting  ct_label marks a connection as one that was previously allowed, but should no longer be allowed due to a policy change.

       This table also contains a priority 0 flow with action next;, so that ACLs allow packets by default.  If the  logical  datapath has a statetful ACL, the following flows will also be added:
    + A  priority-1  flow  that  sets the hint to commit IP traffic to the connection tracker (with action reg0[1] = 1; next;).  This is needed for the default allow policy because, while the initiator’s direction may  not  have  any stateful rules, the server’s may and then its return traffic would not be known and marked as invalid.  
    + A  priority-65535 flow that allows any traffic in the reply direction for a connection that has been committed to the connection tracker (i.e., established flows), as long as the committed flow does not  have  ct_label[0]  set.  We  only handle traffic in the reply direction here because we want all packets going in the request direction to still go through the flows that implement the currently defined policy based on ACLs.   If  a  connection  is  no longer  allowed by policy, ct_label[0] will get set and packets in the reply direction will no longer be allowed, either.
    + A priority-65535 flow that allows any traffic that is considered related to a committed flow  in  the  connection tracker  (e.g.,  an  ICMP Port Unreachable from a non-listening UDP port), as long as the committed flow does not have ct_label[0] set.
    + A priority-65535 flow that drops all traffic marked by the connection tracker as invalid.
    + A priority-65535 flow that drops all trafic in the reply direction with ct_label[0] set meaning that the  connection  should  no  longer be allowed due to a policy change.  Packets in the request direction are skipped here to let a newly created ACL re-allow this connection.
*/
procedure acl(lport : LogicalSwitchPort, dir : acl_dir_t) : (bool, bool) = {
    // XXX: how to determine if the logical datapath has a stateful ACL
    if (ct_inv()) {
        (false, false)
    } else if ((not ct_new()) and ct_rpl() and (ct_label()[0:0] == 0)) {
        (true, true)
    } else if (ct_rel() and (ct_label()[0:0] == 0)) {
        (true, true)
    } else if (ct_rpl() and (ct_label()[0:0] == 1)) {
        (false, false)
    } else {
        the (acl in ACL | eval(acl.match_cond)(pkt, lport.id) and acl.lswitch == lport.lswitch and acl.direction == dir) {
            match (acl.action) {
                ACLAllow        -> (true, true),
                ACLAllowRelated -> 
                    if (ct_new()) {
                        (true, true)
                    } else {
                        ct_commit(lport.ct_zone, 128'd0); 
                        (true, false)
                    },
                _               ->  
                    if (ct_new()) {
                        (false, false)
                    } else {
                        ct_commit(lport.ct_zone, 128'd1); 
                        (false, false)
                    }
            }
        } default {
            if pktIsIP(pkt) {
                (true, true)
            } else {
                (true, false)
            }
        }
    }
}

/* Ingress Table 8: LB
    It  contains a priority-0 flow that simply moves traffic to the next table. For established connections a priority 100 flow matches on ct.est && !ct.rel && !ct.new && !ct.inv and sets an action reg0[2] = 1; next; to act as a hint for table Stateful to send packets through connection tracker to NAT the packets. (The packet will automatically get DNATed to the same IP address as the first packet in that connection.)

    Ingress Table 9: Stateful
    · For all the configured load balancing rules for a switch in OVN_Northbound database that includes a L4 port PORT of protocol P and IPv4 address VIP, a priority-120 flow that matches on ct.new && ip && ip4.dst == VIP && P && P.dst == PORT with an action of ct_lb(args), where args contains comma separated IPv4 addresses (and optional port numbers) to load balance to.
    · For all the configured load balancing rules for a switch in OVN_Northbound database that includes just an IP address VIP to match on, a priority-110 flow that matches on ct.new && ip && ip4.dst == VIP with an action of ct_lb(args), where  args  contains  comma  separated  IPv4 addresses.
    · A priority-100 flow commits packets to connection tracker using ct_commit; next; action based on a hint provided by the previous tables (with a match for reg0[1] == 1).
    · A priority-100 flow sends the packets to connection tracker using ct_lb; as the action based on a hint provided by the previous tables (with a match for reg0[2] == 1).
    · A priority-0 flow that simply moves traffic to the next table.
 */
procedure ingressLB(lport : LogicalSwitchPort, commit : bool) : () = {
    any (lb in LPortLBVIPIP | ct_new() and 
                              lb.lport == lport.id and
                              match(pkt.payload) { 
                                  EthIP4{IP4Pkt{_,_,_,_,_,_,proto,_,dst,l4}} ->
                                      lb.proto == proto and 
                                      lb.vip.addr == dst and 
                                      ( (lb.vip.prt == 0) or
                                        match (l4) {
                                              IPTCP{TCPPkt{_, dport, _}}    -> lb.vip.prt == dport,
                                              IPUDP{UDPPkt{_, dport, _, _}} -> lb.vip.prt == dport,
                                              _ -> false
                                        } ),
                                  _ -> false
                              } ) {
        ct_lb(lport.ct_zone, IPAddr4{lb.ip.addr}, lb.ip.prt)
    } default {
        if (ct_est() and (not ct_rel()) and (not ct_new()) and (not ct_inv())) {
            if (pkt.ethtype == 16'h800) { ct_lb(lport.ct_zone) }
        } else if commit {
            ct_commit(lport.ct_zone)
        } 
    }
}

/* Ingress Table 10: ARP/ND responder

       This  table implements ARP/ND responder in a logical switch for known IPs. The advantage of the ARP responder flow is to limit ARP broadcasts by locally responding to ARP requests without the need to send to other hypervisors. One common case is when the inport is a logical port associated with a VIF and the broadcast is responded to on the local hypervisor rather than broadcast across the whole network and responded to by the destination VM. This behavior is proxy ARP.

    · Priority-100 flows to skip the ARP responder if inport is of type localnet or vtep and advances directly to the next table. ARP requests sent  to  localnet  or  vtep ports  can  be  received  by  multiple  hypervisors. Now, because the same mac binding rules are downloaded to all hypervisors, each of the multiple hypervisors will respond. This will confuse L2 learning on the source of the ARP requests. ARP requests received on an inport of type router are  not  expected  to  hit  any  logical switch  ARP  responder flows. However, no skip flows are installed for these packets, as there would be some additional flow cost for this and the value appears limited.

    · Priority-50 flows that match ARP requests to each known IP address A of every logical switch port, and respond with ARP replies directly with corresponding  Ethernet address E:

     eth.dst = eth.src;
     eth.src = E;
     arp.op = 2; // ARP reply. 
     arp.tha = arp.sha;
     arp.sha = E;
     arp.tpa = arp.spa;
     arp.spa = A;
     outport = inport;
     flags.loopback = 1;
     output;

     These flows are omitted for logical ports (other than router ports or localport ports) that are down.

    · Priority-50  flows  that  match  IPv6 ND neighbor solicitations to each known IP address A (and A’s solicited node address) of every logical switch port, and respond with neighbor advertisements directly with corresponding Ethernet address E:

     nd_na {
         eth.src = E;
         ip6.src = A;
         nd.target = A;
         nd.tll = E;
         outport = inport;
         flags.loopback = 1;
         output;
     };

     These flows are omitted for logical ports (other than router ports or localport ports) that are down.

    · Priority-100 flows with match criteria like the ARP and ND flows above, except that they only match packets from the inport that owns the IP addresses  in  question, with action next;. These flows prevent OVN from replying to, for example, an ARP request emitted by a VM for its own IP address. A VM only makes this kind of request to attempt to detect a duplicate IP address assignment, so sending a reply will prevent the VM from accepting the IP address that it owns.

    In place of next;, it would be reasonable to use drop; for the flows’ actions. If everything is working as it is  configured,  then  this  would  produce  equivalent results,  since no host should reply to the request. But ARPing for one’s own IP address is intended to detect situations where the network is not working as configured, so dropping the request would frustrate that intent.

    · One priority-0 fallback flow that matches all packets and advances to the next table.
*/
/* Returns true if this is an ARP request packet that has been modified to generate an ARP
   response.  The caller must send this response back to the sender.  */
procedure arp(lport : LogicalSwitchPort) : bool = {
    match (lport.ptype) {
        LPortLocalnet{_} -> false,
        _                -> {
            match (pkt.payload) {
                EthARP{ARPPkt{ARPRequest, spa, tpa, sha, tha}} -> {
                    // ignore requests for sender's own IP
                    the (lpaddr in LPortMACIP | lpaddr.lport == lport.id and lpaddr.ip == IPAddr4{tpa}) {
                        false
                    } default {
                        the (lpaddr in LPortMACIP | lpaddr.lswitch == lport.lswitch and lpaddr.ip == IPAddr4{tpa}) {
                            mkARPResp(lpaddr.mac, tpa);
                            true
                        } default {
                            false
                        }
                    }
                },
                EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NS{ICMP6NSPkt{target, _}}}}}} -> {
                    the (lpaddr in LPortMACIP | lpaddr.lport == lport.id and lpaddr.ip == IPAddr6{target}) {
                        false
                    } default {
                        the (lpaddr in LPortMACIP | lpaddr.lswitch == lport.lswitch and lpaddr.ip == IPAddr6{target}) {
                          // XXX: send to controller
                          /*
                            pkt.dst = pkt.src;
                            pkt.src = lpaddr.mac;
                            pkt.payload.ip6.src = target;
                            pkt.payload.ip6.payload.icmp6.type = 136;
                            pkt.payload.ip6.payload.icmp6.code = 0;
                            //pkt.payload.ip6.payload.icmp6.payload.na.target = target;
                            pkt.payload.ip6.payload.icmp6.payload.na.tll = lpaddr.mac;
                            true */ 
                            false
                            /*pkt.dst = pkt.src;
                            pkt.src = lpaddr.mac;
                            pkt.payload.ip6.src = target;
                            pkt.payload.ip6.payload.icmp6.payload = ICMP6NA{ICMP6NAPkt{target, lpaddr.mac}};
                            // XXX: what does this compile to?
                            // flags.loopback = 1;
                            true*/
                        } default {
                            false
                        }
                    }
                },
                _ -> false
            }
        }
    }
}

/* Ingress Table 11: DHCP option processing

    This table adds the DHCPv4 options to a DHCPv4 packet from the logical ports configured with IPv4 address(es) and DHCPv4 options, and similarly for DHCPv6 options.
    · A priority-100 logical flow is added for these logical ports which matches the IPv4 packet with udp.src = 68 and udp.dst = 67 and applies  the  action  put_dhcp_opts and advances the packet to the next table.
                     reg0[3] = put_dhcp_opts(offer_ip = ip, options...);
                     next;
    For  DHCPDISCOVER  and DHCPREQUEST, this transforms the packet into a DHCP reply, adds the DHCP offer IP ip and options to the packet, and stores 1 into reg0[3]. For other kinds of packets, it just stores 0 into reg0[3]. Either way, it continues to the next table.
    · A priority-100 logical flow is added for these logical ports which matches  the  IPv6  packet  with  udp.src  =  546  and  udp.dst  =  547  and  applies  the  action put_dhcpv6_opts and advances the packet to the next table.
                     reg0[3] = put_dhcpv6_opts(ia_addr = ip, options...);
                     next;
    For  DHCPv6  Solicit/Request/Confirm  packets,  this  transforms the packet into a DHCPv6 Advertise/Reply, adds the DHCPv6 offer IP ip and options to the packet, and stores 1 into reg0[3]. For other kinds of packets, it just stores 0 into reg0[3]. Either way, it continues to the next table.
    · A priority-0 flow that matches all packets to advances to table 11.

     Ingress Table 12: DHCP responses
     This table implements DHCP responder for the DHCP replies generated by the previous table.
    · A priority 100 logical flow is added for the logical ports configured with DHCPv4 options which matches IPv4 packets with udp.src == 68 && udp.dst == 67  &&  reg0[3] == 1 and responds back to the inport after applying these actions. If reg0[3] is set to 1, it means that the action put_dhcp_opts was successful.
                     eth.dst = eth.src;
                     eth.src = E;
                     ip4.dst = A;
                     ip4.src = S;
                     udp.src = 67;
                     udp.dst = 68;
                     outport = P;
                     flags.loopback = 1;
                     output;

     where  E  is  the server MAC address and S is the server IPv4 address defined in the DHCPv4 options and A is the IPv4 address defined in the logical port’s addresses column.
                     (This terminates ingress packet processing; the packet does not go to the next ingress table.)
*/

#controller
procedure dhcp4(lport : lport_id_t, chassis : chassis_id_t) : sink = {
    the (dhcp_addr_opts in LPortDHCP4AddrOpts | dhcp_addr_opts.lport == lport) {
        pkt.dst = pkt.src;
        pkt.src = dhcp_addr_opts.options.server_mac;
        pkt.payload.ip4.dst = dhcp_addr_opts.ip;
        pkt.payload.ip4.src = dhcp_addr_opts.options.server_id;
        pkt.payload.ip4.payload.udp.src = 67;
        pkt.payload.ip4.payload.udp.dst = 68;
        pkt.payload.ip4.payload.udp.payload = UDPDHCP4{DHCP4Pkt{ 2, 1, 6, pkt.payload.ip4.payload.udp.payload.dhcp4.xid, 0, 
                                                                 pkt.payload.ip4.payload.udp.payload.dhcp4.flags,
                                                                 0, dhcp_addr_opts.ip, dhcp_addr_opts.options.server_id, 0, 
                                                                 pkt.dst ++ 80'h0, dhcp_addr_opts.options} };
        the (lp in LogicalSwitchPort | lp.id == lport) {
            bounce(lp, chassis)
        }
    } default { drop }
}

#controller
procedure dhcp6(lport : lport_id_t, chassis : chassis_id_t) : sink = {
    the (dhcp_addr_opts in LPortDHCP6AddrOpts | dhcp_addr_opts.lport == lport) {
        pkt.dst = pkt.src;
        pkt.src = dhcp_addr_opts.options.server_id.mac;
        pkt.payload.ip6.dst = dhcp_addr_opts.ip;
        pkt.payload.ip6.src = dhcp_addr_opts.server_ip;
        pkt.payload.ip4.payload.udp.src = 547;
        pkt.payload.ip4.payload.udp.dst = 546;
        if ( (pkt.payload.ip4.payload.udp.payload.dhcp6.op == 1/*SOLICIT*/) or 
             (pkt.payload.ip4.payload.udp.payload.dhcp6.op == 3/*REQUEST*/) or 
             (pkt.payload.ip4.payload.udp.payload.dhcp6.op == 4/*CONFIRM*/) or 
             (pkt.payload.ip4.payload.udp.payload.dhcp6.op == 5/*RENEW*/) ) {
            pkt.payload.ip4.payload.udp.payload = UDPDHCP6{DHCP6Pkt{7/*REPLY*/, dhcp_addr_opts.options} };
            the (lp in LogicalSwitchPort | lp.id == lport) {
                bounce(lp, chassis)
            }
        } else { drop }
    } default { drop }
}

#controller
procedure dns(lport : lport_id_t) : sink = {
    // TODO: call DNS lookup builting
    drop
}


// bounce the  packet back to the port is arrived from after local ARP or DHCP processing
procedure bounce(lport : LogicalSwitchPort, chassis : chassis_id_t): sink = {
    pkt.portnum = 0;
    deliver(lport, chassis)
}


/* Ingress Table 15 Destination Lookup
    This table implements switching behavior. It contains these logical flows:
    · A  priority-100  flow  that  outputs all packets with an Ethernet broadcast or multicast eth.dst to the MC_FLOOD multicast group, which ovn-northd populates with all enabled logical ports.
    · One priority-50 flow that matches each known Ethernet address against eth.dst and outputs the packet to the single associated output port.
    For the Ethernet address on a logical switch port of type router, when that logical switch port’s addresses column is set to router and the connected logical  router port specifies a redirect-chassis:
        · The flow for the connected logical router port’s Ethernet address is only programmed on the redirect-chassis.  
        · If  the  logical  router  has  rules specified in nat with external_mac, then those addresses are also used to populate the switch’s destination lookup on the chassis where logical_port is resident.
    · One priority-0 fallback flow that matches all packets and outputs them to the MC_UNKNOWN multicast group, which ovn-northd populates with all enabled  logical  ports that  accept  unknown destination packets. As a small optimization, if no logical ports accept unknown destination packets, ovn-northd omits this multicast group and logical flow.
*/
procedure dstLookup(lport : LogicalSwitchPort, chassis : chassis_id_t): sink = {
    /* Compute chassis to forward the packet to */
    var dst : destination_t;
    if (ethMulticastAddr(pkt.dst)) {
        /* fork to all chassis that host this switch */
        fork (lschassis in LSwitchAtChassis | lschassis.sender == chassis and lschassis.lswitch == lport.lswitch) {
            dst = lschassis.chassis
        }
    } else {
        /* find matching chassis */
        the (mchassis in MACChassis | mchassis.lswitch == lport.lswitch and mchassis.mac == pkt.dst) {
            dst = mchassis.chassis
        } default {
            /* destination unknown: send to all chassis that host ports with unknown addresses */
            fork (uchassis in UnknownMACChassis | uchassis.sender == chassis and uchassis.lswitch == lport.lswitch) {
                dst = uchassis.chassis
            }
        }
    };
    sendToChassis(chassis, lport, dst)
}

// Send packet to specified chassis.  
procedure sendToChassis(chassis : chassis_id_t, lport : LogicalSwitchPort, dst : destination_t): sink = {
    match (dst) {
        DSTLocal            -> (),
        DSTChassis{dstchassis} -> {
            the (dtun in TunnelFromTo | dtun.toChassis == dstchassis and dtun.fromChassis == chassis) {
                pkt.vxlan.tun_dst = dtun.toip;
                pkt.vxlan.tun_id  = lport.lswitch;
                the (stun in TunnelPort | stun.switch == chassis) {
                    send PTunnelPort[stun].out
                }
            } default { () }
        }
    };
    vSwitchEgress(true, chassis, lport.lswitch)
}

/* Packet arrives to VSwitch ready for logical switch port egress 
   processing.  Establish port(s) it belongs to and call lportEgress.
   The first argument is true iff the packet originated at the local 
   switch. */
procedure vSwitchEgress(local : bool, chassis: chassis_id_t, lswitch : lswitch_id_t) : sink = {
    /* multicast? - deliver to all local ports on this switch */
    var lport : lport_id_t;
    if (ethMulticastAddr(pkt.dst)) {
        if (local) {
            fork(lp in LPortAtChassis | lp.lswitch == lswitch and lp.chassis == chassis) {
                lport = lp.lport
            }
        } else {
            fork(lp in LPortAtChassis | lp.lswitch == lswitch and lp.chassis == chassis and (not lp.float)) {
                lport = lp.lport
            }
        }
    } else {
        /* unicast - deliver to port that owns the address, or to all ports with unknown addresses */
        the (lp in LPortMACChassis | lp.lswitch == lswitch and 
                                     lp.chassis == chassis and 
                                     lp.mac == pkt.dst and 
                                     (lp.float => local)) {
            lport = lp.lport
        } default {
            /* destination unknown: send to all chassis that host ports with unknown addresses */
            if (local) {
                fork (lp in LPortUnknownMACChassis | lp.lswitch == lswitch and lp.chassis == chassis) {
                    lport = lp.lport
                }
            } else {
                fork (lp in LPortUnknownMACChassis | lp.lswitch == lswitch and lp.chassis == chassis and (not lp.float)) {
                    lport = lp.lport
                }
            }
        }
    };
    the (lp in LogicalSwitchPort | lp.id == lport) {
        lportEgress(lp, chassis)
    }
}

procedure lportEgress(lport: LogicalSwitchPort, chassis : chassis_id_t): sink = {
    /* Run through connection tracker if needed */
    egressConnTrack(lport);

    var lbcommit = egressLB(lport);

    /* acl */
    (var allowed, var aclcommit) = acl(lport, ACLTo);
    if (not allowed) {
        drop
    } else if (lbcommit and (pkt.ethtype == 16'h800)) {
        ct_lb(lport.ct_zone)
    } else if (aclcommit) {
        ct_commit(lport.ct_zone)
    };

    if (not egressPortSecurity(lport, pkt)) drop;

    deliver(lport, chassis)
}

procedure deliver(lport : LogicalSwitchPort, chassis : chassis_id_t): sink = {
    match (lport.ptype) {
        LPortRouter{rpid}   -> lrouterIngress(rpid, chassis, false), 
        _ -> ()
    };

    var lp : lport_id_t;
    lp = match (lport.ptype) {
        LPortVIF{p,_,t}         -> { pkt.vlan.vid = t; p },  
        _                       -> lport.id
    };
    the (lb in LPortBinding | lb.lport == lp) {
        the (vport in VSwitchPort | vport.id == lb.vport and vport.switch == chassis) { 
            send PVSwitchPort[vport].out 
        }
    }
}

procedure egressConnTrack(lport : LogicalSwitchPort): () = {
    var needCT = false;
    the (lp in LPortStatefulACL | lp.lport == lport.id) {
        needCT = true
    } default { () };

    the (lp in LPortLB | lp.lport == lport.id) {
        needCT = true
    } default { () };

    // sends the packet to connection tracker
    if (needCT) {
        ct(lport.ct_zone)
    }
}

procedure egressLB(lport : LogicalSwitchPort) : bool = {
    ct_est() and (not ct_rel()) and (not ct_new()) and (not ct_inv())
}

/*  
    Egress Table 7: Egress Port Security - IP
    This is similar to the port security logic in table Ingress Port Security - IP except that outport, eth.dst, ip4.dst and ip6.dst are checked instead of  inport,  eth.src,  ip4.src and ip6.src

    Egress Table 8: Egress Port Security - L2

    This  is  similar to the ingress port security logic in ingress table Admission Control and Ingress Port Security - L2, but with important differences. Most obviously, outport and eth.dst are checked instead of inport and eth.src. Second, packets directed to broadcast or multicast eth.dst are always accepted instead of being subject  to  the  port  security rules;  this  is implemented through a priority-100 flow that matches on eth.mcast with action output;. Finally, to ensure that even broadcast and multicast packets are not delivered to disabled logical ports, a priority-150 flow for each disabled logical outport overrides the priority-100 flow with a drop; action.
*/
function egressPortSecurity(lport: LogicalSwitchPort, p: Packet): bool = {
    if (not lport.enabled) {
        false
    } else if (ethMulticastAddr(p.dst)) {
        true 
    } else { 
        the (psec in PortSecurityType | psec.lport == lport.id) {
            if (psec.stype == PortSecNone) { true }
            else {
                the (psecmac in PortSecurityMAC | psecmac.lport == lport.id and psecmac.mac == p.dst) {
                    match (psec.stype) {
                        PortSecIP -> egressPortSecIP(lport, p),
                        _         -> true
                    }
                } default { false }
            }
        }
    }
}

function egressPortSecIP(lport: LogicalSwitchPort, p: Packet): bool = {
    if (isPktDHCPDiscovery(p) or isPktDAD(p)) {
        true
    } else {
        the (psecip in PortSecurityIP | psecip.lport == lport.id and psecip.mac == p.dst and ipDstMatch(p.payload, psecip.subnet)) {
            true
        } default { false }
    }
}

function ipDstMatch(p: eth_payload_t, subnet: ip_subnet_t): bool = {
    match ((p, subnet)) {
        (EthIP4{ip4}, IPSubnet4{subnet4}) -> ip4Match(ip4.dst, subnet4),
        (EthIP6{ip6}, IPSubnet6{subnet6}) -> ip6Match(ip6.dst, subnet6),
        _                                 -> false
    }
}

procedure tunIngress(port: TunnelPort): sink = {
    if (pkt.vxlan.tun_id[23:23] == 0) {
        vSwitchEgress(false, port.switch, pkt.vxlan.tun_id)
    } else {
        rportEgress(port.switch, pkt.vxlan.tun_id[31:0], true)
    }
}

procedure lrouterIngress(rpid : lrouter_port_id_t, chassis : chassis_id_t, egress_loopback : bool) : sink = {
    var rport = the (rp in LogicalRouterPort | rp.id == rpid) { rp };
    var localGW = the (rp in LogicalRouterPort | rp.id == rpid and rp.ptype == LRPGateway{chassis}) { true } default { false };
    if (not rport.enabled) { drop };

    // L2 admission control
    if (not l2AdmissionControl(rport, chassis, pkt)) { drop };

    // L3 admission control
    if (not l3AdmissionControl(rport, chassis, egress_loopback, pkt)) { drop };

    // ARP request and response processing
    var bounce = rportARPReq(rport, chassis, localGW);
    if (bounce) {
        rportDeliver(rport, chassis)
    };

    // address learning
    match (pkt.payload) {
        EthARP{ARPPkt{ARPReply, spa, tpa, sha, tha}} -> ctlPutARP(rport.id, spa, sha),
        _ -> ()
    };

    // process IP packets for IP addresses owned by the router
    rportIP(rport, chassis, localGW)
}

function l2AdmissionControl(rport : LogicalRouterPort, chassis : chassis_id_t, p : Packet) : bool = {
    if (p.vlan.vid != 0 or ethMulticastAddr(p.src)) {
        false
    } else {
        the (rp in LogicalRouterPort | rp.id == rport.id and (p.dst == rp.mac or ethMulticastAddr(p.dst)) and
                                       match(rp.ptype){
                                           LRPRegular    -> true,
                                           LRPGateway{c} -> c == chassis
                                       }) {
            true
        } default {
            // XXX: Why does this rule only apply to DNAT_SNAT rules
            the (nat in NATChassis | rportIsGW(rport.ptype) and nat.lrouter == rport.lrouter and nat.ntype == DNAT_SNAT and 
                                     nat.external_mac == SomeMACAddr{p.dst} and chassis == nat.chassis) {
                true
            } default { false }
        }
    }
}


function l3AdmissionControl(rport : LogicalRouterPort, chassis : chassis_id_t, egress_loopback : bool, p : Packet) : bool = {
    var srcip = pktSrcIP(p);
    match (p.payload) {
        EthIP4{ip4} -> {
            if (ip4MulticastAddr(ip4.src) or ip4.src == 32'hffffffff or 
                ip4.src[31:24] == 127 or ip4.dst[31:24] == 127 or
                ip4.src[31:24] == 0 or ip4.dst[31:24] == 0) {
                false
            } else {
                the (lrn in LRouterNetwork | lrn.lrouter == rport.lrouter and 
                                             match (lrn.network) {
                                                 IPSubnet4{sn4} -> ip4.src == (sn4.addr | ~sn4.mask),
                                                 _              -> false
                                             }) {
                    false
                } default { true }
            }
        }, 
        _ -> true
    } and {
        the (lrn in LRouterNetwork | lrn.lrouter == rport.lrouter and SomeIPAddr{ipSubnetAddr(lrn.network)} == srcip) {
            // unless REG_BIT_EGRESS_LOOPBACK
            egress_loopback
        } default { true }
    }
}


// Returns true iff the packet must be bounced back to the sender
procedure rportARPReq(rport : LogicalRouterPort, chassis : chassis_id_t, localGW : bool) : bool = {
    match (pkt.payload) {
        EthARP{ARPPkt{ARPRequest, spa, tpa, sha, tha}} -> {
            the (lrn in LRouterPortNetwork | lrn.lport == rport.id and 
                                             (rport.ptype == LRPRegular or localGW) and
                                             match (lrn.network) {
                                                 IPSubnet4{sn4} -> tpa == sn4.addr,
                                                 _              -> false 
                                             }) {
                mkARPResp(rport.mac, lrn.network.ip4_subnet.addr);
                true
            } default {
                the (lrvip in LRouterLBVIP | lrvip.lrouter == rport.lrouter and tpa == lrvip.vip) {
                    mkARPResp(rport.mac, lrvip.vip);
                    true
                } default {
                    the (nat in NAT | nat.lrouter == rport.lrouter and (nat.ntype == DNAT or nat.ntype == DNAT_SNAT) and
                                      nat.external_ip == tpa and 
                                         (rport.ptype == LRPRegular or
                                          match (nat.external_mac) {
                                              NoMACAddr -> localGW,
                                              _         -> false
                                          })) {
                        mkARPResp(rport.mac, nat.external_ip);
                        true
                    } default {
                        the (nat in NATChassis | nat.lrouter == rport.lrouter and (nat.ntype == DNAT or nat.ntype == DNAT_SNAT) and
                                                 nat.external_ip == tpa and 
                                                 match (nat.external_mac) {SomeMACAddr{_} -> true, _ -> false} and
                                                 match (rport.ptype) {
                                                     LRPGateway{_} -> chassis == nat.chassis,
                                                     _             -> false
                                                 }) {
                            mkARPResp(nat.external_mac.addr, nat.external_ip);
                            true
                        } 
                    }
                }
            }
        },
        _ -> false  
    }
}

procedure rportIP(rport : LogicalRouterPort, chassis : chassis_id_t, localGW : bool) : sink = {
    var handled : bool;
    // IP packets that are handled locally by the router
    match (pkt.payload) {
        // ICMP6 NA
        EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NA{ICMP6NAPkt{target, tll}}}}}} -> {
            ctlPutND(rport.id, target, tll) // sink
        },
        // ICMP6 NS
        EthIP6{IP6Pkt{_,_,_,_,_,src,dst,IPICMP6{ICMP6Pkt{_,_,ICMP6NS{ICMP6NSPkt{target, sll}}}}}} ->  {
            the (lrn in LRouterPortNetwork | lrn.lport == rport.id and 
                                             (rport.ptype == LRPRegular or localGW) and
                                             match (lrn.network) {
                                                IPSubnet6{sn6} -> sn6.addr == target and dst == target,
                                                _              -> false
                                             }) { 
                drop
                // XXX: TODO: allow non-sink controller methods
                /*
                ctlMkNA(rport.id, src, sll, lrn.network.ip6_subnet.addr, rport.mac);
                rportBounce(rport, chassis) // sink
                */
            } default { 
                ctlPutND(rport.id, src, sll) // sink
            }
        },
        // ICMP4 echo
        EthIP4{IP4Pkt{_,_,_,_,_,_,_,_,dst,IPICMP4{ICMP4Pkt{type, code}}}} -> {
            the (lrn in LRouterNetwork | type == 8 and code == 0 and lrn.lrouter == rport.lrouter and 
                                         match (lrn.network) {
                                            IPSubnet4{sn4} -> sn4.addr == dst,
                                            _              -> false
                                         }) {
                pkt.payload.ip4.dst = pkt.payload.ip4.src;
                pkt.payload.ip4.ttl = 255;
                pkt.payload.ip4.payload.icmp4.type = 0;
                handled = true
            } default { () }
        },
        // ICMP6 echo
        EthIP6{IP6Pkt{_,_,_,_,_,_,dst,IPICMP6{ICMP6Pkt{type, code, _}}}} -> {
            if (type == 128 and code == 0) {
                the (lrn in LRouterNetwork | lrn.lrouter == rport.lrouter and 
                                             match (lrn.network) {
                                                IPSubnet6{sn6} -> sn6.addr == dst,
                                                _              -> false
                                             }) {
                    pkt.payload.ip6.dst = pkt.payload.ip6.src;
                    pkt.payload.ip6.ttl = 255;
                    pkt.payload.ip6.payload.icmp6.type = 129;
                    handled = true
                } default { () }
            } else { () }
        },
        _ -> { () }
    };
    
    // drop packets sent to router's IP address that it is not expected to handle
    if (not handled) {
        match (pkt.payload) {
            EthIP4{IP4Pkt{_,_,_,_,_,ttl,_,_,dst,_}} -> {
                the (lrn in LRouterNetwork | lrn.lrouter == rport.lrouter and 
                                             match (lrn.network) {
                                                 IPSubnet4{sn4} -> sn4.addr == dst,
                                                 _              -> false
                                             }) {
                    the (nat in NAT | nat.lrouter == rport.lrouter and 
                                      match (lrn.network) {
                                          IPSubnet4{sn4} -> nat.external_ip == sn4.addr,
                                          _              -> false 
                                      } and 
                                      (nat.ntype == SNAT or nat.ntype == DNAT_SNAT)) {
                        ()
                    } default { drop }
                } default {
                    if (ttl == 0 or ttl == 1) { drop }
                }
            },
            EthIP6{IP6Pkt{_,_,ttl,_,_,_,dst,_}} -> {
                the (lrn in LRouterNetwork | lrn.lrouter == rport.lrouter and 
                                             match (lrn.network) {
                                                 IPSubnet6{sn6} -> sn6.addr == dst,
                                                 _              -> false
                                             }) {
                    drop
                } default {
                    if (ttl == 0 or ttl == 1) { drop }
                }
            }
        };  
        if (ethBroadcastAddr(pkt.dst)) { drop }
    };

    // ingress NAT
    var nat_redirect = unsnat(rport, chassis);
    var dnat_redirect = dnat(rport, chassis);
    if (dnat_redirect) {
       nat_redirect = true
    };

    // IP routing
    var rt: opt_route_t;
    if (nat_redirect) {
        dec_ttl();
        the (gwport in LogicalRouterPort | gwport.lrouter == rport.lrouter and rportIsGW(gwport.ptype)) {
            pkt.dst = gwport.mac
        }
    } else {
        rt = route(rport, chassis);
        match (rt) {
            NoRoute -> { drop },
            SomeRoute{r} -> {
                if (rt.route.nexthop == NoIPAddr) {
                    rt.route.nexthop = pktDstIP(pkt)
                };

                // ARP/ND resolution
                resolve(rport, chassis, rt.route);
            
                // gateway redirect
                the (orport in LogicalRouterPort | match(rt) {SomeRoute{srt} -> orport.id == srt.outport, _ -> false}) {
                    if (pkt.dst == 0 and rportIsGW(orport.ptype)) {
                        nat_redirect = true
                    } else {
                        the  (nat in NAT | nat.lrouter == rport.lrouter and SomeIPAddr{IPAddr4{nat.logical_ip.addr}} == pktSrcIP(pkt) and (nat.logical_port != NoLPortId)) { () }
                        default { 
                            if rportIsGW(orport.ptype) {
                                nat_redirect = true 
                            }
                        }
                    }
                }
            }
        }
    };
    
    // ARP request
    if (pkt.dst == 0) {
        match ((rt.route.outportip, rt.route.nexthop)) {
            (IPAddr4{oip}, SomeIPAddr{IPAddr4{nip}}) -> {
                rportSendARPReq(chassis, rt.route.outport, oip, nip)
            },
            // XXX: should we send an ND message for IP6 address? The man page does not say so
            _ -> drop
        }
    };

    if (nat_redirect) {
        the (dtun in TunnelFromTo | LRPGateway{dtun.toChassis} == rport.ptype and dtun.fromChassis == chassis) {
            pkt.vxlan.tun_dst = dtun.toip;
            pkt.vxlan.tun_id  = rport.lrouter;
            the (stun in TunnelPort | stun.switch == chassis) {
                send PTunnelPort[stun].out
            }
        } default { 
            // no tunnel -- must be local chassis
            rportEgress(chassis, rt.route.outport, true) 
        }
    };

    rportEgress(chassis, rt.route.outport, false)
}

procedure unsnat(rport : LogicalRouterPort, chassis : chassis_id_t) : bool = {
    match ((pkt.payload, rport.ptype)) {
        (EthIP4{ip4}, LRPGateway{rchassis}) -> {
            the (nat in NATChassis | nat.lrouter == rport.lrouter and 
                                     (nat.ntype == SNAT or nat.ntype == DNAT_SNAT) and 
                                     ip4.dst == nat.external_ip and
                                     match (nat.external_mac) {NoMACAddr -> nat.chassis == chassis, _ -> true}) {
                ct_snat(rport.ct_zone);
                false
            } default { true }
        },
        _ -> false
    }
}

procedure dnat(rport : LogicalRouterPort, chassis : chassis_id_t) : bool = {
    match ((pkt.payload, rport.ptype)) {
        (EthIP4{ip4}, LRPGateway{rchassis}) -> {
            the (nat in NATChassis | nat.lrouter == rport.lrouter and 
                                     (nat.ntype == DNAT or nat.ntype == DNAT_SNAT) and 
                                     ip4.dst == nat.external_ip and
                                     match (nat.external_mac) { NoMACAddr -> nat.chassis == chassis, _ -> true}) {
                ct_dnat(rport.ct_zone, nat.logical_ip.addr);
                false
            } default { (true) }
        },
        _ -> false
    }
}

typedef opt_route_t = NoRoute
                    | SomeRoute{route : Route}

procedure route(rport : LogicalRouterPort, chassis : chassis_id_t) : opt_route_t = {
    match (pkt.payload) {
        EthIP4{ip4} -> {
            the (r in Route | r.lrouter == rport.lrouter and
                              match(r.ip_prefix) {
                                  IPSubnet4{sn4} -> ip4Match(ip4.dst, sn4),
                                  _ -> false
                              }) {
                dec_ttl();
                pkt.src = r.outportmac;
                SomeRoute{r}
            } default { NoRoute }
        },
        EthIP6{ip6} -> {
            the (r in Route | r.lrouter == rport.lrouter and
                              match(r.ip_prefix) {
                                  IPSubnet6{sn6} -> ip6Match(ip6.dst, sn6),
                                  _ -> false
                              }) {
                dec_ttl();
                pkt.src = r.outportmac;
                SomeRoute{r}
            } default { NoRoute }
        },
        _ -> NoRoute
    }
}

procedure resolve(rport : LogicalRouterPort, chassis : chassis_id_t, route: Route) : () = {
    // TODO: only consider addresses on the attached logical switch
    the (addr in LPortMACIP | SomeIPAddr{addr.ip} == route.nexthop) {
        pkt.dst = addr.mac
    } default {
        the (addr in LearnedAddress | addr.rport == rport.id and SomeIPAddr{addr.ip} == route.nexthop) {
            pkt.dst = addr.mac
        } default {
            pkt.dst = 0 // address unknown
        }
    }
}

procedure rportEgress(chassis : chassis_id_t, rpid : lrouter_port_id_t, redirected : bool) : sink = {
    var rport = the (rp in LogicalRouterPort | rp.id == rpid) { rp };
    undnat(rport, chassis);
    snat(rport, chassis);

    /* Egress Table 2: Egress Loopback

        For distributed logical routers where one of the logical router ports specifies a redirect-chassis.

        Earlier in the ingress pipeline, some east-west traffic was redirected to the chassisredirect port, based on flows in the UNSNAT and DNAT ingress tables  setting  the REGBIT_NAT_REDIRECT flag, which then triggered a match to a flow in the Gateway Redirect ingress table. The intention was not to actually send traffic out the distributed gateway port instance on the redirect-chassis. This traffic was sent to the distributed gateway port instance in order for DNAT and/or SNAT processing to be applied.

        While UNDNAT and SNAT processing have already occurred by this point, this traffic needs to be forced through egress loopback on this distributed gateway port instance, in order for UNSNAT and DNAT processing to be applied, and also for IP routing and ARP resolution after all of  the  NAT  processing, so that the packet can be forwarded to the destination.

        This table has the following flows:
        · For  each NAT rule in the OVN Northbound database on a distributed router, a priority-100 logical flow with match ip4.dst == E && outport == GW, where E is the external IP address specified in the NAT rule, and GW is the logical router distributed gateway port, with the following actions:
         clone {
             ct_clear;
             inport = outport;
             outport = "";
             flags = 0;
             flags.loopback = 1;
             reg0 = 0;
             reg1 = 0;
             ...
             reg9 = 0;
             REGBIT_EGRESS_LOOPBACK = 1;
             next(pipeline=ingress, table=0);
         };

         flags.loopback is set since in_port is unchanged and the packet may return back to that port after NAT processing. REGBIT_EGRESS_LOOPBACK is set to indicate that egress loopback has occurred, in order to skip the source IP address check against the router address.
    */
    if (redirected) {
        lrouterIngress(rport.id, chassis, true)
    };
    rportDeliver(rport, chassis)
}

procedure rportDeliver(rport : LogicalRouterPort, chassis : chassis_id_t) : sink = {
    pkt.portnum = 0;
    match (rport.peer) {
        NoPeer         -> the (lport in LogicalSwitchPort | match (lport.ptype) {
                                                               LPortRouter{rpid2} -> rpid2 == rport.id,
                                                               _ -> false 
                                                            }) {
                              lportIngress(lport, chassis)
                          } default { drop },
        SomePeer{peer} -> lrouterIngress(peer, chassis, false)
    }
}

/* Egress Table 0: UNDNAT

    This is for already established connections’ reverse traffic. i.e., DNAT has already been done in ingress pipeline and now the packet has entered  the  egress pipeline  as  part of a reply. For NAT on a distributed router, it is unDNATted here. For Gateway routers, the unDNAT processing is carried out in the ingress DNAT table.

    · For each configuration in the OVN Northbound database that asks to change the destination IP address of a packet from an IP address of A to B, a priority-100 flow matches ip && ip4.src == B && outport == GW, where GW is the logical router gateway port, with an action ct_dnat;.
      If the NAT rule cannot be handled in a distributed manner, then the priority-100 flow above is only programmed on the redirect-chassis.
                     If the NAT rule can be handled in a distributed manner, then there is an additional action eth.src = EA;, where EA is the ethernet address associated with the IP address A in the NAT rule. This allows upstream MAC learning to point to the correct chassis.
    · A priority-0 logical flow with match 1 has actions next;.
*/
procedure undnat(rport : LogicalRouterPort, chassis : chassis_id_t) : () = {
    match ((pkt.payload, rport.ptype)) {
        (EthIP4{ip4}, LRPGateway{rchassis}) -> {
            the (nat in NAT | nat.lrouter == rport.lrouter and (nat.ntype == DNAT or nat.ntype == DNAT_SNAT) and ip4.src == nat.logical_ip.addr and
                              match (nat.external_mac) {
                                  NoMACAddr -> chassis == rchassis,
                                  SomeMACAddr{_} -> true
                              }) {
                ct_dnat(rport.ct_zone);
                match (nat.external_mac) {
                    SomeMACAddr{mac} -> {
                        pkt.src = mac
                    },
                    _ -> ()
                }
            } default { () }
        },
        _ -> ()
    }
}

/* Egress Table 1: SNAT
   Packets that are configured to be SNATed get their source IP address changed based on the configuration in the OVN Northbound database.

   · For each configuration in the OVN Northbound database, that asks to change the source IP address of a packet from an  IP  address  of  A  or  to change  the  source  IP  address of a packet that belongs to network A to B, a flow matches ip && ip4.src == A && outport == GW, where GW is the logical router gateway port, with an action ct_snat(B);. The priority of the flow is calculated based on the mask  of  A,  with  matches  having larger masks getting higher priorities.
                     If the NAT rule cannot be handled in a distributed manner, then the flow above is only programmed on the redirect-chassis.
                     If the NAT rule can be handled in a distributed manner, then there is an additional action eth.src = EA;, where EA is the ethernet address associated with the IP address A in the NAT rule. This allows upstream MAC learning to point to the correct chassis.
   · A priority-0 logical flow with match 1 has actions next;.
*/
procedure snat(rport : LogicalRouterPort, chassis : chassis_id_t) : () = {
    match ((pkt.payload, rport.ptype)) {
        (EthIP4{ip4}, LRPGateway{rchassis}) -> {
            the (nat in NATChassis | nat.lrouter == rport.lrouter and 
                                     (nat.ntype == SNAT or nat.ntype == DNAT_SNAT) and 
                                     ip4.src == nat.logical_ip.addr and
                                     nat.external_mac == NoMACAddr and
                                     nat.chassis == chassis) {
                ct_snat(rport.ct_zone, nat.external_ip)
            } default {
                the (nat in NATChassis | nat.lrouter == rport.lrouter and 
                                         (nat.ntype == SNAT or nat.ntype == DNAT_SNAT) and 
                                         ip4.src == nat.logical_ip.addr) {
                    ct_snat(rport.ct_zone, nat.external_ip);
                    pkt.src = nat.external_mac.addr
                } default { () }
            }
        },
        _ -> ()
    }
}

/*
#controller
procedure ctlMkNA(rport : lrouter_port_id_t, srcip : ip6_addr_t, srcmac : mac_addr_t, rportip : ip6_addr_t, rportmac : mac_addr_t) : () = {
    putND(rport, srcip, srcmac);
    pkt.src = rportmac;
    pkt.payload.ip6.src = rportip;
    pkt.payload.ip6.icmp6 = ICMP6Pkt{136, 0, ICMP6NA{ICMP6NAPkt{rportip, rportmac}}}
}*/

#controller
procedure rportSendARPReq(chassis : chassis_id_t, rport : lrouter_port_id_t, oip : ip4_addr_t, nip : ip4_addr_t) : sink = {
    pkt.dst = 48'hffffffffffff;
    pkt.payload = EthARP{ARPPkt{ARPRequest, oip, nip, pkt.src, 48'hffffffffffff}};
    rportEgress(chassis, rport, false) 
}

#controller
procedure ctlPutARP(rport : lrouter_port_id_t, ip : ip4_addr_t, mac : mac_addr_t) : sink = {
    LearnedAddress.put(LearnedAddress{rport, IPAddr4{ip}, mac});
    drop
}

#controller
procedure ctlPutND(rport : lrouter_port_id_t, ip : ip6_addr_t, mac : mac_addr_t) : sink = {
    LearnedAddress.put(LearnedAddress{rport, IPAddr6{ip}, mac});
    drop
}

procedure mkARPResp(mac : mac_addr_t, ip : ip4_addr_t): () = {
    pkt.dst = pkt.src;
    pkt.src = mac;
    pkt.payload.arp.op = ARPReply;
    pkt.payload.arp.tha = pkt.payload.arp.sha;
    pkt.payload.arp.sha = mac;
    pkt.payload.arp.tpa = pkt.payload.arp.spa;
    pkt.payload.arp.spa = ip
}
