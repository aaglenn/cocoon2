include(`tables.ccn')
include(`views.ccn')
undefine(`eval')

switch SChassis[Chassis]

port PVSwitchPort[VSwitchPort](source vSwitchIngress, sink)

procedure vSwitchIngress(port: VSwitchPort): sink = {
    var lport : LogicalSwitchPort;
    if (pkt.vlan.vid == 0) {
        the (p in LogicalSwitchPort | p.id == port.id and p.enabled) {
            lport = p
        } default { drop }
    } else {
        // trunk port? find VIF interface; strip vlan tag
        the (p in LogicalSwitchPort | p.ptype.parent == p.id and p.ptype.tag == pkt.vlan.vid and p.enabled) {
            lport = p;
            pkt.vlan.vid = 0
        } default { drop }
    };
   
    lportIngress(lport, pkt)
}


// XXX: TODO: QoS marking
procedure lportIngress(lport: LogicalSwitchPort, p: Packet): sink = {
    if (not portSecurityAllowed(lport, pkt)) drop;
    // Run through connection tracker if needed
    connTrack(lport);
    // acl
    (var allowed, var commit) = acl(lport);
    if (not allowed) drop;
    // load balancing
    lb(lport, commit);

/*
    arp();
    dhcp();
    dns();
    if (multicast/broadcast) {
    } else {
    }
*/
    drop
}

function portSecurityAllowed(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress table 0 contains these logical flows:
        · Priority 100 flows to drop packets with VLAN tags or mul‐
          ticast Ethernet source addresses.

        · Priority  50  flows  that implement ingress port security
          for each enabled logical port. For logical ports on which
          port  security is enabled, these match the inport and the
          valid eth.src address(es) and advance only those  packets
          to  the  next flow table. For logical ports on which port
          security is not enabled, these advance all  packets  that
          match the inport.

        There  are no flows for disabled logical ports because the default-drop
        behavior of logical flow tables causes packets that ingress  from  them
        to be dropped. 
    */
    if (ethMulticastAddr(p.src)) {
        false 
    } else { 
        the (psec in PortSecurityType | psec.lport == lport.id) {
            if (psec.stype == PortSecNone) { true }
            else {
                the (psecmac in PortSecurityMAC | psecmac.lport == lport.id and psecmac.mac == p.src) {
                    match ((p.payload, psec.stype)) {
                        (EthARP{_}, _)   -> portSecARP(lport, p),
                        (EthOther{_}, _) -> true,
                        (_, PortSecIP)   -> portSecIP(lport, p),
                        _                -> true
                    }
                } default { false }
            }
        }
    }
}

function portSecIP(lport: LogicalSwitchPort, p: Packet): bool = {
    /* Ingress Table 1: Ingress Port Security - IP
       Ingress table 1 contains these logical flows:
          · For each element in the port security set having one or more IPv4 or IPv6 addresses (or both),
             · Priority 90 flow to allow IPv4 traffic if it has IPv4 addresses which match the inport, valid eth.src and valid ip4.src address(es).
             · Priority 90 flow to allow IPv4 DHCP discovery traffic if it has a valid eth.src. This is necessary since  DHCP  discovery  messages are sent from the unspecified IPv4 address (0.0.0.0) since the IPv4 address has not yet been assigned.
             · Priority 90 flow to allow IPv6 traffic if it has IPv6 addresses which match the inport, valid eth.src and valid ip6.src address(es).
             · Priority  90  flow  to  allow  IPv6  DAD (Duplicate Address Detection) traffic if it has a valid eth.src. This is is necessary since DAD include requires joining an multicast group and sending neighbor solicitations for the newly assigned address. Since no address  is  yet assigned, these are sent from the unspecified IPv6 address (::).
             · Priority 80 flow to drop IP (both IPv4 and IPv6) traffic which match the inport and valid eth.src.
          · One priority-0 fallback flow that matches all packets and advances to the next table.
    */
    if (isPktDHCPDiscovery(p) or isPktDAD(p)) {
        true
    } else {
        the (psecip in LogicalSwitchPortIP | psecip.lport == lport.id and psecip.mac == p.src and ipSrcMatch(p.payload, psecip.ip)) {
            portSecNDP(lport, p)
        } default { false }
    }
}

function ipSrcMatch(p: eth_payload_t, subnet: ip_subnet_t): bool = {
    match ((p, subnet)) {
        (EthIP4{ip4}, IPSubnet4{subnet4}) -> ip4Match(ip4.src, subnet4),
        (EthIP6{ip6}, IPSubnet6{subnet6}) -> ip6Match(ip6.src, subnet6),
        _                                 -> false
    }
}

function isPktDHCPDiscovery(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,_,EthIP4{IP4Pkt{_,_,_,_,_,_,_,_,sip,dip,IPUDP{UDPPkt{sport,dport,_}}}}} -> 
            sip == 0 and dip == 32'hffffffff and sport == 68 and dport == 67,
        _                                                                                            -> false
    }
}

function isPktDAD(p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,sip,_,IPICMP6{ICMP6Pkt{ptype,_,_}}}}} -> ptype == 135 and sip == 0,
        _                                                                                    -> false
    }
}

/* Ingress Table 2: Ingress Port Security - Neighbor discovery
   Ingress table 2 contains these logical flows:
      · For each element in the port security set,
         · Priority  90  flow  to  allow  ARP  traffic  which  match  the inport and valid eth.src and arp.sha. If the element has one or more IPv4 addresses, then it also matches the valid arp.spa.
         · Priority 90 flow to allow IPv6 Neighbor Solicitation and Advertisement traffic which match the inport, valid eth.src and  nd.sll/nd.tll.  If the element has one or more IPv6 addresses, then it also matches the valid nd.target address(es) for Neighbor Advertisement traffic.
         · Priority 80 flow to drop ARP and IPv6 Neighbor Solicitation and Advertisement traffic which match the inport and valid eth.src.
      · One priority-0 fallback flow that matches all packets and advances to the next table.
*/
function portSecARP(lport: LogicalSwitchPort, p: Packet): bool = {
    the (psecarp in PortSecurityIP4Match | psecarp.lport == lport.id and 
                                           psecarp.mac == p.src and 
                                           psecarp.mac == p.payload.arp.sha and 
                                           ip4Match(p.payload.arp.spa, psecarp.subnet)) {
        true
    } default { false }
}

function portSecNDP(lport: LogicalSwitchPort, p: Packet): bool = {
    match (p) {
        EthPacket {_,_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NS{ICMP6NSPkt{_, sll}}}}}}} -> 
            the (psec in PortSecurityMAC | psec.lport == lport.id and psec.mac == p.src and psec.mac == sll) {
                true
            } default { false },
        EthPacket {_,_,_,_,_,_,EthIP6{IP6Pkt{_,_,_,_,_,_,_,IPICMP6{ICMP6Pkt{_,_,ICMP6NA{ICMP6NAPkt{target, tll}}}}}}} -> 
            the (psec in PortSecurityIP6Match | psec.lport == lport.id and psec.mac == p.src and psec.mac == tll and ip6Match(target, psec.subnet)) {
                true
            } default { false },
        _ -> true
    }
}
/*
 Ingress Table 3: from-lport Pre-ACLs
   This table prepares flows for possible stateful ACL processing in ingress table ACLs.  It contains a priority-0 flow that  simply moves traffic to the next table.  If stateful ACLs are used in the logical datapath, a priority-100 flow is added that sets a hint (with reg0[0] = 1; next;) for table Pre-stateful to send IP packets to the connection tracker before eventually  advancing to ingress table ACLs.

 Ingress Table 4: Pre-LB
   This table prepares flows for possible stateful load balancing processing in ingress table LB and Stateful.  It contains a priority-0 flow that simply moves traffic to the next table.  If load balancing rules with virtual IP addresses  (and  ports)  are configured  in  OVN_Northbound database for a logical switch datapath, a priority-100 flow is added for each configured virtual IP address VIP with a match ip && ip4.dst == VIP that sets an action reg0[0] = 1; next; to act as a hint for table Pre-stateful to send IP packets to  the  connection  tracker for packet de-fragmentation before eventually advancing to ingress table LB.

 Ingress Table 5: Pre-stateful
   This table prepares flows for all possible stateful processing in next tables.  It contains a priority-0 flow that simply moves traffic to the next table.  A priority-100 flow sends the packets to connection tracker based on a hint provided by the  previous tables (with a match for reg0[0] == 1) by using the ct_next; action.
*/

procedure connTrack(lport : LogicalSwitchPort): () = {
    var needCT = false;
    the (lp in LPortStatefulACL | lp.lport == lport.id) {
        needCT = true
    } default { () };

    the (lbvip in LPortLBVIP | lbvip.lport == lport.id and lbvip.vip.addr == pkt.payload.ip4.dst) {
        needCT = true
    } default { () };

    // sends the packet to connection tracker
    pkt.ct.track = true
}

/*
     Ingress table 6: from-lport ACLs
       Logical  flows  in this table closely reproduce those in the ACL table in the OVN_Northbound database for the from-lport direction. The priority values from the ACL table have a limited range and have 1000 added to them to leave  room  for  OVN  default flows at both higher and lower priorities.
    · allow  ACLs translate into logical flows with the next; action.  If there are any stateful ACLs on this datapath, then allow ACLs translate to ct_commit; next; (which acts as a hint for the next tables to commit the  connection to conntrack),
    · allow-related  ACLs  translate into logical flows with the ct_commit(ct_label=0/1); next; actions for new connections and reg0[1] = 1; next; for existing connections.
    · Other ACLs translate to drop; for new or untracked connections and  ct_commit(ct_label=1/1);  for  known  connections.   Setting  ct_label marks a connection as one that was previously allowed, but should no longer be allowed due to a policy change.

       This table also contains a priority 0 flow with action next;, so that ACLs allow packets by default.  If the  logical  datapath has a statetful ACL, the following flows will also be added:
    + A  priority-1  flow  that  sets the hint to commit IP traffic to the connection tracker (with action reg0[1] = 1; next;).  This is needed for the default allow policy because, while the initiator’s direction may  not  have  any stateful rules, the server’s may and then its return traffic would not be known and marked as invalid.  
    + A  priority-65535 flow that allows any traffic in the reply direction for a connection that has been committed to the connection tracker (i.e., established flows), as long as the committed flow does not  have  ct_label[0]  set.  We  only handle traffic in the reply direction here because we want all packets going in the request direction to still go through the flows that implement the currently defined policy based on ACLs.   If  a  connection  is  no longer  allowed by policy, ct_label[0] will get set and packets in the reply direction will no longer be allowed, either.
    + A priority-65535 flow that allows any traffic that is considered related to a committed flow  in  the  connection tracker  (e.g.,  an  ICMP Port Unreachable from a non-listening UDP port), as long as the committed flow does not have ct_label[0] set.
    + A priority-65535 flow that drops all traffic marked by the connection tracker as invalid.
    + A priority-65535 flow that drops all trafic in the reply direction with ct_label[0] set meaning that the  connection  should  no  longer be allowed due to a policy change.  Packets in the request direction are skipped here to let a newly created ACL re-allow this connection.
*/
procedure acl(lport : LogicalSwitchPort) : (bool, bool) = {
    // XXX: how to determine if the logical datapath has a stateful ACL
    if (pkt.ct.inv) {
        (false, false)
    } else if ((not pkt.ct.new) and pkt.ct.rpl and (pkt.ct.commit.label[0:0] == 0)) {
        (true, true)
    } else if (pkt.ct.rel and (pkt.ct.commit.label[0:0] == 0)) {
        (true, true)
    } else if (pkt.ct.rpl and (pkt.ct.commit.label[0:0] == 1)) {
        (false, false)
    } else {
        the (acl in ACL | eval(acl.match_cond)(pkt) and acl.lswitch == lport.lswitch and acl.direction == ACLFrom) {
            match (acl.action) {
                ACLAllow        -> (true, true),
                ACLAllowRelated -> 
                    if (pkt.ct.new) {
                        (true, true)
                    } else {
                        pkt.ct.commit = CTCommit{0,0,CTNATNone}; 
                        (true, false)
                    },
                _               ->  
                    if (pkt.ct.new) {
                        (false, false)
                    } else {
                        pkt.ct.commit = CTCommit{0,1,CTNATNone}; 
                        (false, false)
                    }
            }
        } default {
            if pktIsIP(pkt) {
                (true, true)
            } else {
                (true, false)
            }
        }
    }
}

/* Ingress Table 8: LB
    It  contains a priority-0 flow that simply moves traffic to the next table. For established connections a priority 100 flow matches on ct.est && !ct.rel && !ct.new && !ct.inv and sets an action reg0[2] = 1; next; to act as a hint for table Stateful to send packets through connection tracker to NAT the packets. (The packet will automatically get DNATed to the same IP address as the first packet in that connection.)

    Ingress Table 9: Stateful
    · For all the configured load balancing rules for a switch in OVN_Northbound database that includes a L4 port PORT of protocol P and IPv4 address VIP, a priority-120 flow that matches on ct.new && ip && ip4.dst == VIP && P && P.dst == PORT with an action of ct_lb(args), where args contains comma separated IPv4 addresses (and optional port numbers) to load balance to.
    · For all the configured load balancing rules for a switch in OVN_Northbound database that includes just an IP address VIP to match on, a priority-110 flow that matches on ct.new && ip && ip4.dst == VIP with an action of ct_lb(args), where  args  contains  comma  separated  IPv4 addresses.
    · A priority-100 flow commits packets to connection tracker using ct_commit; next; action based on a hint provided by the previous tables (with a match for reg0[1] == 1).
    · A priority-100 flow sends the packets to connection tracker using ct_lb; as the action based on a hint provided by the previous tables (with a match for reg0[2] == 1).
    · A priority-0 flow that simply moves traffic to the next table.
 */
procedure lb(lport : LogicalSwitchPort, commit : bool) : () = {
    any (lb in LPortLBVIPIP | pkt.ct.new and 
                              lb.lport == lport.id and 
                              lb.proto == pkt.payload.ip4.proto and 
                              lb.vip.addr == pkt.payload.ip4.dst and 
                              ( (lb.proto == 6 and lb.vip.prt == pkt.payload.ip4.payload.tcp.dst) or
                                (lb.proto == 17 and lb.vip.prt == pkt.payload.ip4.payload.udp.dst) or
                                (lb.vip.prt == 0))) {
        pkt.ct.commit = CTCommit { 0, 0, CTNATDNAT{IPAddr4{lb.ip.addr}, lb.ip.prt, CTHash} }
    } default {
        if (pkt.ct.est and (not pkt.ct.rel) and (not pkt.ct.new) and (not pkt.ct.inv)) {
            pkt.ct.commit = CTCommit { 0, 0, CTNATDefault}
        } else if commit {
            pkt.ct.commit = CTCommit { 0, 0, CTNATNone}
        } 
    }
}

procedure lportEgress(port: LogicalSwitchPort): sink = drop 
